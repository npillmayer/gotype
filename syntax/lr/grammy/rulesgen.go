package main

import (
	"bytes"
	"fmt"
	"strings"
	"unicode"

	"golang.org/x/exp/ebnf"
)

// --- Grammar Generation -----------------------------------------------

type generator struct {
	buf     bytes.Buffer
	g       *EBNFGrammar
	rules   map[string][]*rule
	counter int
}

type rule struct {
	lhs     string
	symbols []symbol
}

type symbol struct {
	name   string
	isterm bool
}

func (r *rule) append(sym string, isterm bool) *rule {
	if len(sym) == 0 {
		return r
	}
	if r == nil {
		r = newRule(sym)
	}
	r.symbols = append(r.symbols, symbol{sym, isterm})
	return r
}

func newRule(lhs string) *rule {
	return &rule{
		lhs:     lhs,
		symbols: make([]symbol, 0, 10),
	}
}

func (gen *generator) genRuleCode(r *rule) {
	if len(r.symbols) == 0 {
		gen.Printf("    b.LHS(\"%s\").Epsilon()\n", r.lhs)
		return
	}
	gen.Printf("    b.LHS(\"%s\")", r.lhs)
	for _, sym := range r.symbols {
		if sym.isterm {
			gen.Printf(".L(\"%s\")", sym.name)
		} else {
			gen.Printf(".N(\"%s\")", sym.name)
		}
	}
	gen.Printf(".End()\n")
}

func (gen *generator) appendRule(lhs string, r *rule) {
	if r == nil {
		return
	}
	r.lhs = lhs
	rules, ok := gen.rules[r.lhs]
	if ok {
		rules = append(rules, r)
		gen.rules[r.lhs] = rules
	} else {
		gen.rules[r.lhs] = []*rule{r}
	}
}

// GenerateBuilder generates Go source code for a grammar builder.
func GenerateBuilder(g *EBNFGrammar) (string, error) {
	gen := &generator{g: g, rules: make(map[string][]*rule)}
	gen.Printf("// Code generated by \"ebnfcom -grammar %s\"; DO NOT EDIT.\n", g.Name)
	gen.Printf("package %s\n\n", basepkgname(g.pkgname))
	gen.Printf("import \"github.com/npillmayer/gotype/syntax/lr\"\n\n")
	gen.Printf("func MakeGrammar%s() (*lr.Grammar, error) {\n", gen.g.Name)
	gen.Printf("    b := lr.NewGrammarBuilder(\"%s\")\n", gen.g.Name)
	gen.GenerateHookCode()
	gen.GenerateRules()
	gen.Printf("    return b.Grammar()\n")
	gen.Printf("}\n")
	return gen.buf.String(), nil
}

// Generate Go source code for setting a token-generator hook for the grammar builder.
func (gen *generator) GenerateHookCode() {
	if gen.g.hook != "-" {
		gen.Printf("    b.SetTokenizerHook(%s)\n", gen.g.hook)
	}
}

func (gen *generator) GenerateRules() {
	fmt.Printf("// Grammar builder for %d productions\n", len(gen.g.ebnf))
	for i, prod := range gen.g.ebnf {
		fmt.Printf("// Code for production #%s\n", i)
		switch expr := prod.Expr.(type) {
		case ebnf.Alternative:
			for _, alt := range expr {
				gen.RHS(prod.Name.String, alt)
			}
		default:
			gen.RHS(prod.Name.String, expr)
		}
	}
	fmt.Printf("// Grammar builder done\n")
	gen.RulesCode()
}

func (gen *generator) RHS(lhs string, rhs ebnf.Expression) {
	if lhs != "Term" {
		//return
	}
	var r *rule
	switch e := rhs.(type) {
	case ebnf.Sequence:
		gen.Sequence(lhs, "", e, 0)
	case *ebnf.Option:
		nonterm := gen.createID()
		r = r.append(nonterm, false)
		gen.Option(nonterm, e, 0)
	case *ebnf.Group:
		nonterm := gen.createID()
		r = r.append(nonterm, false)
		gen.Group(nonterm, e, 0)
	case *ebnf.Repetition:
		nonterm := gen.createID()
		r = r.append(nonterm, false)
		gen.Repetition(nonterm, e, 0)
	case ebnf.Alternative:
		gen.Printf("ERROR: OR-element needs group")
		name := "ERROR"
		r = r.append(name, false)
	case nil:
		r = newRule(lhs) // epsilon
	case *ebnf.Name:
		r = r.append(e.String, isLower(e.String))
	case *ebnf.Token:
		r = r.append(e.String, true)
	default:
		gen.Printf("ERROR: unknown element in RHS\n")
	}
	gen.appendRule(lhs, r)
}

func (gen *generator) Sequence(lhs string, prefix string, seq ebnf.Sequence, nesting int) *rule {
	var r *rule
	if len(prefix) > 0 {
		r = r.append(prefix, false)
	}
	for _, expr := range seq {
		switch e := expr.(type) {
		case *ebnf.Name:
			r = r.append(e.String, isLower(e.String))
		case *ebnf.Token:
			r = r.append(e.String, true)
		case *ebnf.Group:
			nonterm := gen.createID()
			r = r.append(nonterm, false)
			gen.Group(nonterm, e, 0)
		case *ebnf.Repetition:
			nonterm := gen.createID()
			r = r.append(nonterm, false)
			gen.Repetition(nonterm, e, 0)
		case *ebnf.Option:
			nonterm := "Opt" + gen.createID()
			r = r.append(nonterm, false)
			gen.Option(nonterm, e, nesting+1)
		case ebnf.Alternative:
			gen.Printf("ERROR: OR-element needs group")
			name := "ERROR"
			r = r.append(name, false)
		}
	}
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Group(lhs string, grp *ebnf.Group, nesting int) *rule {
	var r *rule
	switch e := grp.Body.(type) {
	case *ebnf.Name:
		r = r.append(e.String, isLower(e.String))
	case *ebnf.Token:
		r = r.append(e.String, true)
	case *ebnf.Group:
		name := "ERROR: nested groups"
		r = r.append(name, false)
	case *ebnf.Repetition:
		r = r.append("ERROR: repetition element in group", false)
	case *ebnf.Option:
		r = r.append("ERROR: optional element in group", false)
	case ebnf.Alternative:
		gen.Alternative(lhs, e, nesting+1)
	}
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Repetition(lhs string, rep *ebnf.Repetition, nesting int) *rule {
	var r *rule
	switch o := rep.Body.(type) {
	case *ebnf.Name:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		r = r.append(lhs, false)
		r = r.append(o.String, isLower(o.String))
	case *ebnf.Token:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		r = r.append(lhs, false)
		r = r.append(o.String, false)
	case *ebnf.Option:
		gen.Printf("Optional element not allowed in repetition.")
	case ebnf.Sequence:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		gen.Sequence(lhs, lhs, o, nesting)
	case *ebnf.Repetition:
		gen.Printf("Nested optional elements not allowed.")
	case ebnf.Alternative:
		gen.appendRule(lhs, newRule(lhs)) // epsilon
		r = r.append(lhs, false)
		// for _, expr := range o {
		// 	gen.Alternative(lhs, expr, nesting+1)
		// }
	}
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Alternative(lhs string, alt ebnf.Expression, nesting int) *rule {
	r := newRule(lhs)
	r = r.append("ALTERNATIVE", false)
	gen.appendRule(lhs, r)
	return r
}

func (gen *generator) Option(lhs string, opt *ebnf.Option, nesting int) *rule {
	var r *rule
	switch o := opt.Body.(type) {
	case *ebnf.Name:
		r = r.append(o.String, isLower(o.String))
	case *ebnf.Token:
		r = r.append(o.String, false)
	case *ebnf.Option:
		gen.Printf("Nested optional elements not allowed.")
	case ebnf.Sequence:
		nonterm := gen.createID()
		r = r.append(nonterm, false)
		r = gen.Sequence(nonterm, "", o, nesting)
	case *ebnf.Repetition:
		gen.Printf("Nested optional elements not allowed.")
	case ebnf.Alternative:
		name := "invented_AAA"
		r = r.append(name, false)
		for _, alt := range o {
			gen.Alternative(lhs, alt, nesting+1)
		}
	}
	gen.appendRule(lhs, r)
	r = newRule(lhs)
	gen.appendRule(lhs, r) // add epsilon rule
	return r
}

func (gen *generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&gen.buf, format, args...)
}

func (gen *generator) RulesCode() {
	startrules := gen.rules[gen.g.Start]
	for _, r := range startrules {
		gen.genRuleCode(r)
	}
	delete(gen.rules, gen.g.Start)
	for _, rules := range gen.rules {
		for _, r := range rules {
			gen.genRuleCode(r)
		}
	}
}

func (gen *generator) createID() string {
	gen.counter++
	return fmt.Sprintf("N%05d", gen.counter)
}

func isLower(s string) bool {
	return unicode.IsLower(rune(s[0]))
}

// GenerateParser generates Go source code for a parser for the given grammar.
func GenerateParser(g *EBNFGrammar) error {
	return fmt.Errorf("grammy.GenerateParser() not yet implemented")
}

func basepkgname(pkgname string) string {
	s := strings.Split(pkgname, "/")
	return s[len(s)-1]
}
